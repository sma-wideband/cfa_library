function stream_vacc_init(blk, varargin)
% Initialize and configure the cross-correlator, which can then be
% processed using an FFT after the final adder to get baseline
% visibilities.
%
% cross_correlator_init(blk, varargin)
%
% blk = The block to configure.
% varargin = {'varname', 'value', ...} pairs
% 
% Valid varnames for this block are:
% acc_len = Number of samples to accumulate
% total_lags = Size of the correlator and subsequent FFT 

% Declare any default values for arguments you might like.
defaults = {...
    'vector_len', 5,...
    'input_bit_width', 18,...
    'input_bin_pt', 14,...
    'samples_out', 3,...
    'output_bit_width', 22,...
    'output_bin_pt', 14,...
    'quantization', 'Truncate',...
    'overflow', 'Wrap',...
    'specify_add', 'off',...
    'add_spec', 'Fabric',...
    'add_delay', 1};
if same_state(blk, 'defaults', defaults, varargin{:}), return, end
check_mask_type(blk, 'stream_vacc');
munge_block(blk, varargin{:});

% Get the necessary mask parameters.
vector_len = get_var('vector_len', 'defaults', defaults, varargin{:});
input_bit_width = get_var('input_bit_width', 'defaults', defaults, varargin{:});
input_bin_pt = get_var('input_bin_pt', 'defaults', defaults, varargin{:});
samples_out = get_var('samples_out', 'defaults', defaults, varargin{:});
output_bit_width = get_var('output_bit_width', 'defaults', defaults, varargin{:});
output_bin_pt = get_var('input_bin_pt', 'defaults', defaults, varargin{:});
quantization = get_var('quantization', 'defaults', defaults, varargin{:});
overflow = get_var('overflow', 'defaults', defaults, varargin{:});
specify_add = get_var('specify_add', 'defaults', defaults, varargin{:});
add_spec = get_var('add_spec', 'defaults', defaults, varargin{:});
add_delay= get_var('add_delay', 'defaults', defaults, varargin{:});

% Remove all lines, will be redrawn later
delete_lines(blk);

x0 = 30; % where we'll start to draw blocks, everything
y0 = 32; % will be relative to this position

width = 30;
height = 16;
port_ysep = 100;
chan_ysep = port_ysep*(2^vector_len);
reuse_block(blk, 'sync', 'built-in/inport',...
    'Position', [x0 y0 x0+width y0+height], 'Port', '1');
for i=0:2^floor(vector_len-samples_out)-1,
    % Draw the input data ports, each one is a concatenated set of
    % 2^samples_out vector points
    input_name = ['[', num2str(i*2^samples_out), '-',...
        num2str((i+1)*2^samples_out-1), ']'];
    reuse_block(blk, input_name, 'built-in/inport',...
        'Position', [x0 y0+(i+3)*port_ysep,...
        x0+width y0+(i+3)*port_ysep+height],...
        'Port',  num2str(2+i));
    reuse_block(blk, ['uncram', num2str(i)], 'gavrt_library/uncram',...
        'Position', [x0+3*width y0+(i+3)*port_ysep,...
        x0+4*width y0+(i+3)*port_ysep+height],...
        'Num_Slice', num2str(2^samples_out),...
        'Slice_Width', num2str(input_bit_width),...
        'Bin_Pt', num2str(input_bin_pt),...
        'Arith_Type', '1');
    add_line(blk, [input_name, '/1'],...
        ['uncram', num2str(i), '/1']);
    reuse_block(blk, ['cram', num2str(i)], 'gavrt_library/cram',...
        'Position', [x0+(32+2^samples_out)*width y0+(i+3)*port_ysep,...
        x0+(33+2^samples_out)*width y0+(i+3)*port_ysep+height],...
        'Num_Slice', num2str(2^samples_out));
    for j=0:2^samples_out-1,
        % Here we draw all the single point accumulators
        acc_name = ['acc', num2str(i*2^samples_out+j)];
        reuse_block(blk, acc_name,...
            'dali_library/simple_acc',...
            'Position', [x0+(16+j*2)*width y0+10*j+(i+3)*port_ysep,...
            x0+(17+j*2)*width y0+10*j+(i+3)*port_ysep+height],...
            'Samples', num2str(floor(vector_len-samples_out)),...
            'Data_Type', 'Signed  (2''s comp)',...
            'Bit_Width', num2str(input_bit_width),...
            'Bin_Pt', num2str(input_bin_pt),...
            'Quantization', quantization,...
            'Overflow', overflow,...
            'Specify_Add', specify_add,...
            'Add_Spec', add_spec);
        add_line(blk, ['uncram', num2str(i), '/', num2str(j+1)],...
            [acc_name, '/1']);
        add_line(blk, 'sync/1', [acc_name, '/2']);
        add_line(blk, [acc_name, '/1'],...
            ['cram', num2str(i), '/', num2str(j+1)]);
    end
end

x1 = x0+(34+2^samples_out)*width;
y1 = y0+3*port_ysep;
reuse_block(blk, 'stream_count', 'xbsBasic_r4/Counter',...
    'Position', [x1-3*width y1-3*height x1-2*width y1-2*height],...
    'N_bits', num2str(floor(vector_len-samples_out)),...
    'Rst', 'on');
add_line(blk, 'acc0/3', 'stream_count/1');
reuse_block(blk, 'mux', 'xbsBasic_r4/Mux',...
    'Position', [x1 y1 x1+width y1+3*height],...
    'Inputs', num2str(2^floor(vector_len-samples_out)));
add_line(blk, 'stream_count/1', 'mux/1');
for i=1:2^floor(vector_len-samples_out),
    add_line(blk, ['cram', num2str(i-1), '/1'], ['mux/', num2str(i+1)]);
end
reuse_block(blk, 'last_uncram', 'gavrt_library/uncram',...
    'Position', [x1+3*width y1 x1+4*width y1+height],...
    'Num_Slice', num2str(2^samples_out),...
    'Slice_Width', num2str(input_bit_width),...
    'Bin_Pt', num2str(input_bin_pt),...
    'Arith_Type', '1');
add_line(blk, 'mux/1', 'last_uncram/1');
reuse_block(blk, 'sync_out', 'built-in/outport',...
    'Position', [x1 y0 x1+width y0+height], 'Port', '1');
add_line(blk, 'acc0/3', 'sync_out/1');
for i=0:2^samples_out-1,
    reuse_block(blk, ['conv', num2str(i)], 'xbsBasic_r4/Convert',...
        'Position', [x1+5*width y1+3*i*height x1+6*width y1+(3*i+1)*height],...
        'Arith_Type', 'Signed  (2''s comp)',...
        'N_bits', num2str(output_bit_width),...
        'Bin_Pt', num2str(output_bin_pt),...
        'Quantization', quantization,...
        'Overflow', overflow);
    add_line(blk, ['last_uncram/', num2str(i+1)], ['conv', num2str(i), '/1']);
    output_name = ['[n+', num2str(i), ']'];
    reuse_block(blk, output_name, 'built-in/outport',...
        'Position', [x1+7*width y1+3*i*height x1+8*width y1+(3*i+1)*height],...
        'Port',  num2str(2+i));
    add_line(blk, ['conv', num2str(i), '/1'], [output_name, '/1']);
end


if samples_out<vector_len,
    mode = 'Accumulate';
elseif vector_len<samples_out,
    mode = 'Stack';
else
    mode = 'Pass through';
end

% Clean blocks and finish up.
clean_blocks(blk);
fmtstr = sprintf('%d=>%d samples\n%s',...
    2^vector_len, 2^samples_out, mode);
set_param(blk, 'AttributesFormatString', fmtstr);
save_state(blk, 'defaults', defaults, varargin{:});